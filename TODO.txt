LEFT OFF:
- Fill in AND TEST the base functions of new classes
    - static constructors
        - Decide how 
    - get, insert, append, prepend, replace child - probably can do this in math object??
        - use a PROTECTED function and then expose it as public as needed
        - add special ones to rational and exponent 
    - add operator to term
    - toString
- static constructors
- fill in buildFactor
- Start writing constructor tests and function tests!!!
    - go through each type and function
    - term
        - add a test that there should NOT be an additional operator in the input - this should be stored (if it
            exists) at the expression level
    - expression
        - make sure that the additional operators are stored
- Add these to ALL of objects and test?
    - id
    - children
        - setChildren
- parse the base for log - I think it should EITHER look for the base in the string input OR an optional parameter?
- Update all the copy functions with the tostring?
- Write and test the formatting functions for child classes
- Finish and test: WRITE TESTS ASSUMING THEY ARE PROPERLY FORMATTED AND WRITE NOTES ACCORDINGLY IN THE TESTS
    - parseRationalExpressions
    - parsePowerFactor
- Add the rest of the string formatter error checkers to checkFormattingErrors
- TEST checkFormattingErrors
- Add Optional Parents to constructors
    - THINK ABOUT THIS AND HOW I WANT UPDATING OBJECTS TO WORK!
        - probably return an ENTIRELY clone object but a pointer to the object in the same position
            - will need a way to get an object based on positioning
- Add getters:
    - isRoot,
    - root
    - children
- Start writing basic constructor tests for all child classes
- FORMATTING INPUT STRINGS: 
    - Expression 
        - turn a+-b*c => ?
        - turn a--b*c => a-(-b*c) OR a-(-b)*c?
    - term
        - turn a*b/c*d => a*((b)/(c))*d OR ((a*b)/(c*d))
        - turn a*b/c*d/e => a*((b)/(c))*((d)/(e)) ?
        - turn a*b/c/d => ?
        - turn a/b/c/d => ? OR THROW ERROR??

- How should I handle the following types of situations? They require editing the input slightly. I think I should do options 2 and store the
    original strings and the formatted strings AND FIX THE FAILING UNIT TEST
    - a+-b
        - Option 1 => a-b
        - Option 2 => a+(-b)
    - a--b
        - Option 1 => a+b
        - Option 2 => a--b
- Add sign enum to factor
- Add sign getter to term


GENERAL RULES:
================
- I am allowing ambiguous rational inputs like a/b/c but it will make assumptions without ()
- I am allowing inputs of (a)(b) - it will assume these are two factors
- I am allowing a^b/c => ((a^(b))/(c))
- I am allowing a^b*c => a^(b)*c